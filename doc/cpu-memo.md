# CPUアーキテクチャのメモ
清水駿介

## データパス
各命令の実行時間を固定する．命令発行時にレジスタに命令のディレイを書き込んで，シフタによって命令完了時に消えるようにする．命令完了タイミングで，レジスタの側が出力線を監視して値を取得する．同じレジスタについてディレイが同じになってしまう命令はWAWハザードなので，ストールして再試行．

Branch命令は，executionの1段目でPC書き換えで固定．そうするとPCのWAWハザードを考えなくて良い．即値ジャンプなんかは，後に分岐予測を実装すれば必ず当たる分岐予測として高速化できる．

ここまで1st archでやるかもしれないし，もっと素朴なマルチサイクルでいくかもしれない．

フォワーディングは，ちょうど次のクロックに値が格納されるレジスタがあることを検出した場合，出力線に直結したパスを選択したら可能（クロックが遅くなる心配はある）．

透過的なキャッシュを実装すると，各命令の命令完了時間が分からなくなり得るので，レジスタはただ予約するだけでdelayの情報は与えず，WAWハザードは書き込みが完了するまでストールすることで解決するという，ヘネパタに載ってたスキームを採用する可能性はある．あるいは，Instruction Decode時にキャッシュに載っているかのチェックが行えれば問題ない．

ALU，FPU，Memoryの出力は，最後でorをかけるが，分離しやすいようにしておく．いつか命令同時発行をすることがあるかもしれない．あと，MemoryのStoreでは，データパスはLoadとあまり変わらないものの入力線としてもう一本レジスタに回すことが必要．シフタに回す信号でも，入力と出力を区別する．tristateをSRAMコントローラで隠蔽せずにやるのは死ぬ．

分岐予測すると，Instruction
Fetch部でPCを書き換えつつ，ジャンプ命令が実行されるときに取り出されるようなFIFOに予測したアドレスを突っ込む．FIFOの長さは，FetchとExecutionの間にあるものだから3くらいで良い（あるいはパイプラインレジスタに入れてもいいか）．はずれだったら，レジスタのシフタをクリアして，さらに手前にあるジャンプ命令をどうにかする，などもろもろの処理が必要だが，注意深くやればそれほど複雑な機構を追加することなく多分できる．

## 命令
decode時にハザードの解決およびフォワーディングを行うために，write backまでのディレイの取得が高速にできるようにしたい．

Function部が余るので，そこにディレイを埋め込むようにする（1-4なら2bitで可能）．
