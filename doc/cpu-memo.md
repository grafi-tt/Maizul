# CPUアーキテクチャ内部メモ
清水駿介

In-order Issue，Out-of-order completionのアーキテクチャ．演算器のパイプラインレジスタに書き込み対象とするレジスタのタグを保持しておいて，命令デコード時に各演算器に保持されたタグとオペランドのタグを比較することでストールおよびフォワーディングを行う．ストールは，全て命令デコード時に行う．演算器のパイプラインレジスタが増えるごとに比較すべきタグが増えるので，クロックが上がりにくい可能性有り．レジスタファイル側で書き込みを待つレジスタにビットを立ててやれば回避可能．もっと言えば，予め命令のサイクルが判明している場合，レジスタファイル側にシフトレジスタを入れてレジスタへの書き込みタイミングも管理させることも可能ではある．

ALU，FPU，メモリのそれぞれの実行時間を固定．floorなども，書き込み対象のレジスタがGPRなので，分類上はALUとする．GPRとFPRともにライタポートは一つなので，メモリ書き込みが被った場合は構造ハザードが起こりうる．キャッシュメモリを入れれば構造ハザードは減るはず．floorは現状一クロックで回しているが，それほど速度に響く部分ては無さそうだし二クロックにするのもアリ（その場合，無理やりストールするか，floorの後続の命令を必ずnopにするという規約を定めた上でALU側で適当に処理）．

条件分岐命令の場合でも，無条件分岐命令の場合でも，その他の場合でも，ジャンプ先のアドレスを決定するBranchという名のコンポーネントは常に走っている．アドレス決定は分岐命令と同様に行うが，無条件分岐の場合は必ず条件成立するよう，その他の場合は必ず条件不成立なように，オペランドや比較演算子をデータパスの側で適当にいじくってからBranchに送っている．このような実装にしておくと，ジャンプする場合とそうで無い場合が完全に同等に処理できるようになり，分岐予測周りが少々すっきりする．ただし，複数命令を同時フェッチしようとすると，「次のアドレス」というものが特別な意味を持つこととなってしまい上手くいかなくなる．なお，ソフトウェアでも同様の二律背反はよくある．リンクリストで実装した方が綺麗だけど、キャッシュやSIMDなどを意識してある程度のチャンクを配列にして区切った方が実装効率が上がるアルゴリズムみたいなもの．

ジャンプの予測は，G-Share分岐予測と，スタックによる関数のリターン予測を実装している．ジャンプ先の予測結果を分岐予測コンポーネント内にキューで保持して，Branchから出てきたアドレスと比較することでアドレスの確認を行う．ここで，ストールがあった場合の処理がやや複雑である．前述の通りBranchコンポーネントは常に走っており，ストールする命令に当たった場合でも，必ず裏で走っていて一クロックでストールせずに次のアドレスを返している（もちろんここで得られるアドレスは次の命令のアドレス以外に有り得ないのだが）．なので，このアドレスは正しいアドレスである．その後ろのクロックで，ストールしている命令が正しいアドレスを返すまでは，Branchコンポーネントに入り込んでいるのは一つ先の命令であり，コンポーネントから出てくるアドレスは無視しなければいけない．ストールする命令が結果を返すのは命令実行の最後のクロックにあるのに対して，アドレスの比較は最初のクロックで行なっているのが注意点である．

キャッシュは，1ワード単位のキャッシュでwrite-throughにしてやれば実装は多分単純である．2-wayキャッシュを作ってみる予定．ライトバックを1クロック遅らせて，待ってる間にタグRAMからどちらのwayを最後に使ったかを取得しておき，LRUに従ってwriteを行う．write-firstなブロックRAMを用いるとパフォーマンスのペナルティ無く上手くいくような気がする．

割り込みの実装は，正確な割り込みを実現するにしても，多分ジャンプの実装と大体同じなので現状ではそんなに困難じゃない．もっとも割り込みはちゃんと検討してないので全く自信が無い．

XC5VLX50Tには36KiBのブロックRAMが60個ある．

-   32個 : addr 15bit × value 32bit 命令RAM
-   8個 : addr 13bit × value 32bit キャッシュRAM1
-   8個 : addr 13bit × value 32bit キャッシュRAM2
-   4個 : addr 13bit × value 7bit + 7bit + 1bit キャッシュタグRAM（タグおよび，どちらが最後に使われたかを記録）
-   1個 : addr 10bit × value 36bit 除算テーブル
-   1個 : addr 10bit × value 36bit 平方根テーブル
-   1個 : addr 14bit × value 2bit GShare
-   1個 : addr 11bit × value 16bit スタック

以上のような利用を予定している．ただし，キャッシュが広すぎてクロックを落とす可能性有り．また，命令やキャッシュのサイズは出来れば容易に変更できるようにしておきたい．
