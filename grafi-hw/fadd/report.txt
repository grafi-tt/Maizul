# HW実験 fadd回路
05-131007 清水駿介

激しく遅れてしまって申し訳ありません．

丸めは偶数丸めを行った．入力に無限大もしくは無限小が含まれる場合には対応していない（特に困難ではないが面倒だった）．演算結果が無限大もしくは無限小になる場合には対応している．また，非正規化数には一切対応せず，出力がアンダーフローした場合は直ちに0に丸められる．

`fadd/fadd.vhd`に大まかなロジックの実装を行い，`fadd/block.vhd`にシフト回路を切り分けて実装を行った．`fadd/top.vhd`で，シリアル通信からデータを読み取って，結果を返すようにしている．10万個のランダムな入力で実機テストを行い正しい結果を返すことを確認した．

## 実装および速度
加算回路の実装は，クロックを受け取らない単なる組み合わせ回路として行った．`fadd/TOP.twr`にISEが生成したタイミングレポートがある．

タイミングレポートを見ると，14.52nsというクロックに対して，最長で15.157nsかかっていることが見て取れる．この15.157nsという数値は，加算回路の入力信号から，加算回路の出力信号をシリアル通信で書きだすためのバッファとなる信号までのパスの長さである（加算回路は同期回路で無いので，バッファまでを含めて同期回路となる部分の長さがクロック制約として出力される）．なお，`top.vhd`では加算回路の入出力を5クロックほど間隔をおいて読み取っているので正常に動作する．

タイミングレポートからは，`faddRegister/lenRawSft<8>`という信号のファンアウトが165と大きく，1.470nsの遅延を生じているいることが確認された．また，faddRegister/Madd_frcOutAdder1_addsub0000_cy<23>のファンアウトが56と比較的大きく、1.516nsもの遅延を生じていることが確認された．

`lenRawSft<8>`は，2つの入力のどちらの指数部が大きいかを示す信号であり，シフタへの入力を選択するためなどに用いている．まず1つめの入力の指数部から2つ目の入力の指数部を引いて，結果の正負でシフタへの入力を切り替えて，また負だった場合は0から引くことでシフタへの入力を正に直すという処理を行なっているのだが，ファンアウトの軽減のためには，2つ目の入力の指数部から1つめの入力の指数部を引く回路を並列に入れて，二つの減算結果の正負をバランス良くデータセレクタに入れた方が良かったかもしれないと考えられる．

`Madd_frcOutAdder1_addsub0000_cy<23>`は，仮数部の引き算で繰り下がりが生じたかどうかを表す信号である．繰り下がりが生じた場合は丸めが狂うために，並列に実行していた一つ下の桁を用いた引き算の結果を用いるようにしており，Leading Zeroを取り除く回路への入力のデータセレクタへの入力として用いられている．もっとも，繰り下がりが生じていない場合にはLeading Zeroを取り除く必要が無いので，Leading Zeroを取り除く回路の後ろにデータセレクタを回すこともできる．

この信号は，Leading Zeroを取り除く回路への入力の一番上の桁そのものでもあり，また一つ下の桁を用いた分だけ仮数部を補正する回路への入力にも用いられている．これらの回路のLUTに直結してしまっているせいで、ファンアウトが増えてまた物理的に遠い場所への配線が生じてしまっている可能性が考えられる．実際に確認はしていないが，PlanAheadで見れば確認できると考えられる．クリティカルなパスとなるのはデータセレクタに用いているところであるため，EQUIVALENT_REGISTER_REMOVALを無効化した上で，レジスタを複製してデータセレクタへの入力を速くしてやれば高速化すると考えられる．

あるいは，前述の用にデータセレクタを後ろに回しても良い（この場合も，レジスタを複製してLeading Zeroを取り除く回路への入力の一番上の桁となるところへは高速に入力されるようにすべき）．ただ，そうすることで速くなるかどうかは試してみないとちょっと分からない．というのは，アンダーフローがあったかどうかでもLeading Zeroを取り除く回路の入力を切り替えており，この切替えに`Madd_frcOutAdder1_addsub0000_cy<24>`を用いているために，結局データセレクタを後ろに回したところで，やっぱりデータセレクタへ別の入力が同じようにクリティカルパスに入ってくるからである．なので，後ろにデータセレクタを回した場合，論理的な段数は増えて逆に遅くなってしまう可能性が考えられる．どういうふうにLUTが使われるかをきちんと理解していないために，試してみないとなんとも言えない．

また，加算器のモジュールを同期回路とすれば，クロックと同期した入出力の部分がシリアル通信のIOと独立して，加算器の近くになる可能性が考えうる（今回の加算器だけの実装では関係無いかもしれないが，いずれにせよ複数の演算器を用意した場合はそうすることになる）．また、最終手段としてPlanAheadでエリア配置制約をかけることも考えうる．

これらの対策を施せば，14.52nsでは動作させられる可能性は高いと感じられた．またパイプラインすれば当然速くなると考えられる．

## ソフトウェア実装
`FloatAdder.hs`にソフトウェア実装を行った．ランダムな入力データを生成し，入力をCPU上の浮動小数点数に変換して浮動小数点演算を行った上で非正規化数を0に潰した結果と，ソフトウェア実装を実行結果を比較するプログラムを，`Test.hs`に実装した．Test.hsでは，QuickCheckというライブラリを用いている．`cabal install QuickCheck`などでインストール可能である．

    import Test.QuickCheck
    :load Test.hs FloatAdder.hs
    quickCheckWith (stdArgs {maxSuccess=n}) prop_fadd

 をghci上で実装すると，n個のケースに対するソフトウェア実装のテストを行える．

## シリアル通信
`top.vhd`で，シリアル通信で`0x53 <input1> <input2>`というデータを受け取るごとに，出力を返す回路を実装した．入出力の浮動小数点数はともにビッグエンディアンで表現される．

生のデータをシリアルターミナルから入力するのは面倒であり，またシリアルターミナルを用いるとテストも面倒であるため，`bridge.rb`に標準入力からテキスト入力を受け取ってパースし，シリアル通信で入力をFPGAに渡して出力を取得し，整形して標準出力に書き出すようなソフトウェアを実装した．`bridge.rb`では，ruby-serialportというライブラリを使用している．`gem install serialport`などでインストール可能である．

標準入力から

    2 fadd 01000000000000000000000000000000 01000000000000000000000000000000
    16 fadd 80000000 80000000
    10 fadd 1073741824 1073741824

といった形式のデータを読み込んで，一行読み込むごとに対応する出力を標準出力に書き出す．入力の1つ目の列はテキスト表記に用いる進数を，2つ目の列は命令を，3つ目および4つ目の列は二つの入力を表している．

また，`Test.hs`の入力データを生成する部分を用いて，実機のテストに用いる`bridge.rb`に受け渡せるテストデータを生成するプログラムを，`TestData.hs`に実装した.

    ghc TestData.hs Test.hs FloatAdder.hs
    ./make_test.case.sh n

を実行すると，n個のテストケースを含んだ`input`および`expect`というファイルが生成される．

    cat input | ruby bridge.rb > output
    diff expect output

でテストを行える．

## 苦労した点，あるいは愚痴
*   初め高速な整数加算器を手で実装しようとし，実際にHaskell実装およびVHDL実装（未テスト）も行ったのだが，実際のところFPGAはNANDとかNORとかANDとかORとかで動作するのではなくLUTを用いて動作し，また論理合成の段階で最適化されるために，例えばリップルアダーを実装するのと比べて効果はあまり無いと考えられる．また普通に+や-を用いないとDSPが使われないために，遅くなる可能性しか考えられない．FPGAの動作原理について，簡単に実験のスライドなどで解説が有れば良かったのにと感じた．
*   シリアル通信にモジュールの自前の実装では，データを受信したことを通知する信号を受けて，受信したデータの信号の転送を要求する信号を送ってから，次のクロックでは信号が転送されず，その次のクロックまで待たないといけない．ここで延々とハマってしまい，最終的にISimでタイミングチャートを眺めて発見して解決した．これは，シリアル通信モジュールが完全に同期回路で実装されており，転送要求があるかどうかの確認が同期的に行われるので一クロックを消費してしまうせいであるが，配布されたu232_sendでは（受信と送信の違いがあるが）部分的に非同期に信号を入れているためにこうした問題が起こらず，適当な実装に見えて良く考えられているなと感じた．
*   downtoとtoを混ぜてしまっていてデータが壊れて，修正が面倒だった
