# ハードウェア実験 第9回
05-131007 清水駿介

これも提出が激しく遅れてしまい申し訳ありません．

SRAMコントローラのモジュール（`SRAM.vhd`），[XORShift法](http://ja.wikipedia.org/wiki/Xorshift)により擬似乱数を生成するモジュール（`XORShift.vhd`）を作成した．擬似乱数でSRAMを埋めた後に，SRAMから読み込んだ結果を同じ種から生成された擬似乱数と比較することで，SRAMの読み書きが行えることを確認した．

具体的には，`Top.vhd`で，正常に読み書きできている場合と，一つでもミスが有った場合で，それぞれASCII文字の0か1をシリアル通信で出力するようにしている．`Top.vhd`をそのまま論理合成して基板に書き込んだら0を出力し続けることを確認している．書き込みに用いるデータは常に乱数の信号に固定しているが，この場合だとSRAMコントローラにミスがあった場合，信号が読み込んだデータが流れるはずの信号に流れてしまい，常に現在の乱数と一致するこということが起こり得るので，書き込みに用いるデータを書き込みステート以外の場合では適当な定数に固定させた場合でも動作することを確認した（`Top.vhd`の160行付近参照）．読み込みステートに入る前に空のステートを挟んで，読み込みと書き込みで乱数を意図的に一つずらしてやったら1を出力するようになることも確認した．

SRAMコントローラのモジュールでは，High-Zを用いるtristateの扱いはコントローラ内部で吸収させ，loadするかstoreするかを指定させ，load結果とstore結果を別々に扱うようにした．loadもstoreもしない場合は全てのビットをマスクした上でSRAMにはstoreを指示し（つまり何も起こらない），loadもstoreもしようとした場合の動作は未定義である．クロックについてはコントローラでは吸収せず，loadしたデータはコントローラがload指示の信号を読み取った2クロック後にのみ読み出し可能であり，storeするデータはコントローラがstore指示の信号を受け取った2クロック後にコントローラによって読み出される．loadの2つ後のクロックの立ち上がり地点ではHiになっているような信号を，シフトレジスタの要領で作り，2つ後のクロックの立ち上がりを待たずにこの信号がHiになった地点で非同期的にSRAMのデータ線をHigh-Zにしてやることで，きっちり2クロックだけの遅延になるようにした．

storeするデータを先に受け取ってバッファするような実装も可能であるが，コントローラでそうしてしまうと，メモリ内でのデータコピーが完全にデータを読み込むまで待たないといけなくなるために低速にしか実装出来なくなるといった問題が起こりうる．CPU実験ではCPUを実装することを考えると，パイプライン機構やリザベーションステーションなどの側でどう扱うかを決定すべき問題なのだろうと判断した．

なお，SRAMのZDP（parity bit）は無視している．
